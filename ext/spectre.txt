[quote][pid=258647154,13191205,15]Reply[/pid] [b]Post by [uid=39638696]无罪不欢[/uid] (2018-01-08 16:07):[/b]

总体不错，AMD这段你有实际证据吗？屁股这么歪的？怀疑是给INTEL洗地的，收了钱的。[/quote]
1.我打删除线的部分确实是调侃农企，你也能看到我打上删除线了。我副标题还说农企日常翻身呢，你要不要说我标题不当？
2.你可以往前翻几页回复，我在原贴后面回复贴出了引据论文的相关章节，里面是原作者的推测，除了调侃以外，我的叙述完全没有超出原作者的叙述。
3.你引证的知乎说法同样是猜测
[quote]AMD的做法[b]应该是[/b]，如果步骤2里的鉴权没通过，那么根本不开始步骤3。[/quote]
为什么大家都在猜测，因为细节到这个程度的CPU微结构设计，AMD不主动贴出RTL代码谁也不知道实际情况是什么，这里面的真相已经是他们的商业机密了。
4.后面大家发现更多的现象，例如同样的bug可以读出用户态内存却读不出核态的，联系AMD发布的声明说他们因为有不同的架构设计所以完全不受meltdown影响(单独看这句话不同的架构设计同样也可以理解为较浅的流水线)，所以才有越来越多的[b]猜测[/b]偏向于认为AMD的鉴权设计更严格。这已经超出了我写作时所搜集资料的范围。
5.这个板块有些用户的风气真是有问题，冷战思维，动不动就给人扣帽子。我牺牲自己时间精力给论坛写点科普，你上来就说我拿intel的钱发贴洗地，这操作是不是有点违规？我还正生气呢。
6.哪家公司也没给我钱，我没必要小心翼翼每个字都得写成对某个公司有利。AMD要是觉得我这句话亏欠他了，请AMD派工程师出来写篇更专业的；AMD粉丝要是觉得我亏欠AMD了，笔给你，你来。  

[h]这次的漏洞是啥？[/h]
我们先从机制说起来。这次曝光的漏洞一组三个，基本原理都是一样的。

[h]缓存(Cache)[/h]
CPU执行指令，最大的速度瓶颈不在计算，而在于内存访问。
为了降低内存访问需要的时间，现代CPU全部都设计了缓存。
通俗地说，就是把曾经读过的内存，备一份在速度更快的缓存里。
下次再读同一块数据的时候就可以直接从缓存里取，就会更快。

[h]乱序执行(OOO)[/h]
因为有访存瓶颈，指令之间的执行时间差距可能非常大。
一条普通的计算指令1拍结束。一条访存指令如果缓存命中，需要10到100拍；如果缓存不命中，到内存里取，需要上万拍甚至更多。
如果上一条指令被访存卡了十万拍，后面其他的指令只能等着吗？不可能的，所以现代CPU全部都设计了乱序执行的特性。
把指令比做人的话，
顺序执行就是排队入场，先来后到，一直保持同一个顺序。前边的人停下了，后边所有人都必须跟着停。
乱序执行就好象逛超市，大家排着队进场每人发个编号，之后自由乱逛，到结账的地方如果你前边编号的还有人没出去，你就在出口坐着等会儿，最终实现大家出去的时候仍然按进入的顺序排成一队。
坐着等前边人回来的那个地方，你可以想象有几排椅子的等候区，有个保安看着给大家排号，这个机构学名叫做ROB。

[h]异常[/h]
计算机只有一块内存，这块内存上既存着某个不知名应用的运行信息，也存着你的支付宝密码。
怎么样防止不知名小程序看到你的支付宝密码呢？当程序读内存的时候，CPU会帮忙检查读的地址是否属于这个程序。如果不属于，就是非法访问，CPU会在这条指令上产生一个异常，报操作系统枪毙。
操作系统为了处理异常，有一个要求：如果出现异常，那么异常指令之前的所有指令都已经执行完，异常指令之后的所有指令都尚未执行。
但是我们已经乱序执行了啊，怎么办？所以ROB承担起这个责任。
指令乱序执行的时候，要修改什么东西都暂且记着，不真正修改。只有在从ROB里排队出去的时候，才真正提交修改，维持指令之间的顺序关系。
如果一条指令产生了异常，那么它会带着异常来到ROB排队。ROB按顺序把之前的正常指令全部提交了，看到这条指令带有异常之后就封锁出口，异常指令和其后其他指令会被抛弃掉，不予提交。

[h]投机执行[/h]
分支指令是最讨厌的。例如“如果x<3，则执行a-b-c；否则，就执行d-e-f”。
CPU大超市的入口保安，遇到正常指令只管按顺序放进场，控制下超市里的人流量就OK。但遇到分支指令就会傻掉，因为不等这个分支指令执行完，就不知道该放abc进场，还是放def进场。
能傻傻的等分支出来再继续放人吗？不可能的。现代CPU都设计有投机执行的特性。
入口保安会根据历史上这条分支取过哪边，来猜测这一次会取哪边。比如以前一百次分支都取的是abc那边，那这一次我肯定猜它还会取abc那边，我就直接放abc跟着进去。
万一猜错了？让出口那的ROB把abc取消掉不让他们提交就行了，我这边再放def进去。

[h]微结构侧面效应[/h]
被取消掉的指令不会得到提交，所以它们修改不了任何东西，也不会产生异常。所以我大可以随意去投机执行指令，不会有任何危险，因为大不了我取消掉他们就万事大吉了。——体系结构设计者如是想。
这次的全部几个BUG就都出在这里。被取消掉的指令，虽然不会造成结构上的影响，但在微结构上会留下可以观测的影响——就是缓存。
这些被取消掉的指令不受异常的控制，可以访问任何东西，比如你的支付宝密码，然后借口自己执行错了被取消掉，就不会被操作系统管。
体系结构设计者认为被取消掉的指令看到你的支付宝密码不会产生问题，因为它们留不下任何痕迹，但它们还是留下了：[b]它们曾访问过哪些内存，哪些内存的后续访问就会变快。[/b]

[h]攻击示例[/h]
执行这样一句代码：
[quote]if (x < array1_size)
  y = array2[array1[x] * 4096];[/quote]
看起来这程序好像非常正经，对array1的访问甚至有边界检查，不让下标x超过array1的大小。
这边界检查很重要，因为要访问任何地址，比如你的支付宝密码的第一位(假设为k)，存储在地址v的话，令x=v-array1，array1[x]就是在访问地址v了。
不过这种赤裸裸的越界访问一定会触发异常，然后被操作系统枪决罢了。我们不能那么露骨。

[quote][b]if (x < array1_size)[/b]
  y = array2[array1[x] * 4096];[/quote]
开始执行的第一步，CPU首先会遇到一条分支指令，判断x和array1_size谁大。假设array1_size没在缓存里，CPU需要跑去内存里取。
在把array1_size取回来之前没人知道x和array1_size谁大，于是有一万拍的时间内CPU都不知道这个边界检查是成功了还是失败了，这个时间窗口内CPU将继续投机执行。
CPU猜测可能是x更小，投机执行下面的语句。你会发现这种猜测是可以被攻击者误导的，攻击者可以在开始之前先用x=0多次执行这句代码，让CPU误以为x大多数时候都很小。
但实际上，这次的x突然暗藏杀机，因为x=v-array1，而可爱的CPU就这样被骗过去了。

[quote]if (x < array1_size)
  y = array2[[b]array1[x][/b] * 4096];[/quote]
投机执行的第一步，就是array1[x]，试图访问你的支付宝密码。CPU说不可以，于是给这条指令的脸上贴了一张异常罚单，但仍然允许它带着密码的真实值k到ROB那里去排队。[del]口嫌体正[/del]
如果这条指令没有被撤销，操作系统就会枪毙这个犯规的程序；如果撤销了，那么体系结构设计者相信你绝对没办法活着把k带走。

[quote]if (x < array1_size)
  y = [b]array2[k * 4096][/b];[/quote]
投机执行的第二步。攻击者尝试让投机指令把k留下，而这些最终将被撤销的指令，唯一能留下的信息就是缓存。
第二条投机指令以k作为地址去访问array2。k被乘以一个较大的数值，例如页大小4096，这是出于一个技术细节原因。
假设array2的所有内容都不在缓存中，那么这条指令执行后，将仅有一个位置被加载到缓存上，这个位置的访问速度将明显快于其他位置，这个位置就标明了k的值。

[quote]if (x < array1_size)
  [del]y = array2[array1[x] * 4096];[/del][/quote]
随后，array1_size的值读取到了，CPU后知后觉发现投机执行错了，于是上面投机执行的犯罪指令全部被取消。
然而这时被取消的指令已经留下了一条缓存项，出卖了密码k。
攻击者只需要读取array2的每一个位置，测量读取花费的时间，然后找到读取最快的那个位置对应着k是多少，就这样攻破了你支付宝密码的第一位。

之后攻击者读取一些其他数据，将array1_size和array2再次挤出缓存，使用x=0反复执行这段代码欺骗CPU的分支预测，就可以故伎重施，取出你支付宝密码的下一位，以至于每一位。

[h]Q&A[/h]
[list][*][b]Q：真能取出密码？[/b]
A：真的能。
你问攻击者怎么知道v应当是多少？他不需要知道，他可以读走你系统内存条上的每一个字节，然后写封邮件传回去自己慢慢找。
[img]./mon_201801/04/-5tfljQ5-hmmsK2iT3cSiw-ic.png[/img]
研究人员用这种方法扒出来的Firefox保存的网站密码。

[*][b]Q：为什么CPU说不可以还让指令把密码取走了，不给它取不行吗？口嫌体正？[/b]
A：因为判断访问越界与否是比较耗时的，体系结构设计上通常让取数和判断越界同时进行，互不干扰。最终依赖异常来防止越界访问取得的数值被带走。
如果先判断是否越界再取数，会慢；如果判断越界后再追缴非法取得的数，芯片会太复杂。

[*][b]Q：为什么CPU不在这种情况下把缓存清了？[/b]
A：正常程序也会非常频繁地发生投机执行被撤销、撤销指令访问越界的情况，是无法与恶意攻击区分的。
如果每次发生这种情况都清空缓存，缓存的作用就很低了。

[*][b]Q：我被这漏洞影响了吗？[/b]
A：基本上跑不了，因为这不是某一家公司某一个产品的设计缺陷，而是一个极其广泛的体系结构漏洞，整个学术界长期以来都没有意识到这样的设计是会有问题的。

[*][b]Q：怎样中招？[/b]
A：执行一段攻击者编写的native code。
例如执行了莫名其妙的可执行程序，或者在浏览器上浏览攻击者的网页(浏览器内带有javascript JIT编译器，可以生成攻击者想要的native code)，都会有可能中招。
但BUG是由好人先发现的，技术又很复杂，短时间内坏人还写不出恶意代码。这几天注意更新就行了不用草木皆兵。

[*][b]Q：现有电脑上的漏洞可以修复吗？[/b]
A：可以以性能损失的代价降低被攻击的风险，但无法用软件补丁的方式杜绝。

[*][b]Q：意思是说这个漏洞只能读，不能写或者执行什么吧？[/b]
A：据我所知是只能读。

[*][b]Q：英特尔故意的？[/b]
A：英特尔故意留后门不需要这么麻烦，你小瞧牙膏厂了。

[*][b]Q：AMD翻身了？[/b]
A：农企同样有BUG，但被研究者猜测可能是因为流水线太浅[del]CPU太慢了[/del]，投机执行的恶意代码无法在时间窗口内完成预期的动作，所以实测的攻击代码一直没能成功(针对Meltdown)。[s:ac:喷]

[*][b]Q：国产芯片怎么样了？[/b]
A：看不到逻辑判断不了会不会被影响，会不会有等他们自己发言吧。[del]我的体系结构还是胡伟武教的[/del][s:ac:喘]
所有现代CPU，有OOO有ROB有投机执行反悔的机制，都有可能会中招。
但是龙芯在自主可控的角度来说还不会有太大问题，因为龙芯上面跑的应用也都是我们自己搞的，坦克飞机导弹这些CPU上又不会跑莫名其妙的javascript，即使有同样漏洞也不需要过度担心。

[*][b]Q：我该怎么办？[/b]
A：注意软件更新，特别是浏览器和操作系统，包括你所有的智能设备，无论是PC、Mac还是手机。
例如微软已经发布[url]https://support.microsoft.com/en-us/help/4056890/windows-10-update-kb4056890[/url]，可以降低IE和Edge受到攻击的可能性。
不要执行莫名其妙的程序，下载软件多留个心眼，这一点在任何时候都是对的，本次漏洞期间依然如此。
[/list]

[h]引用[/h]
[url]https://meltdownattack.com/[/url]
[url]https://googleprojectzero.blogspot.co.at/2018/01/reading-privileged-memory-with-side.html[/url]  
